# Implementation Plan: Weekly "Weeks Lived" Automation

## Overview
Implement a scheduled automation that sends a weekly "Life in Weeks" grid visualization showing weeks lived since birth, with reply-aware routing to save reflections in configurable vault locations. The feature will be plugin-based with extensible settings infrastructure.

## User Requirements
- **Birthday**: 1984-04-25 (Wednesday)
- **Schedule**: Every Wednesday (personal week start day)
- **Image Style**: Life in Weeks grid (52 columns Ã— ~90 rows, filled = lived, empty = remaining)
- **Reply Destination**: Configurable (daily note, weekly note, or custom journal)
- **Plugin Settings**: Extensible settings system for plugins

## Architecture Components

### 1. Database Schema Extension
**File**: `src/models/user_settings.py`

Add to `UserSettings` model:
```python
# Life Weeks Settings
date_of_birth: Mapped[Optional[str]] = mapped_column(
    String(10), nullable=True
)  # YYYY-MM-DD format

life_weeks_enabled: Mapped[bool] = mapped_column(
    Boolean, default=False
)

life_weeks_day: Mapped[Optional[int]] = mapped_column(
    Integer, nullable=True
)  # 0=Monday, 6=Sunday (auto-calculated from DOB)

life_weeks_time: Mapped[str] = mapped_column(
    String(10), default="09:00"
)  # HH:MM format

life_weeks_reply_destination: Mapped[str] = mapped_column(
    String(50), default="daily_note"
)  # daily_note, weekly_note, custom_journal

life_weeks_custom_path: Mapped[Optional[str]] = mapped_column(
    String(255), nullable=True
)  # For custom journal path
```

**Migration Strategy**: Add inline `ALTER TABLE` statements in `src/core/database.py::init_database()` with try/except pass (existing pattern).

### 2. Image Generation Service
**New File**: `src/services/life_weeks_image.py`

**Purpose**: Generate "Life in Weeks" grid visualization using Pillow (PIL).

**Key Functions**:
- `calculate_weeks_lived(date_of_birth: str) -> int`: Calculate weeks since birth
- `generate_life_weeks_grid(weeks_lived: int, max_age: int = 90) -> Path`: Create grid image
  - Grid: 52 columns (weeks/year) Ã— 90 rows (years)
  - Filled squares: rgba(0, 123, 255, 0.8) (blue, slight transparency)
  - Empty squares: rgba(220, 220, 220, 0.3) (light gray, very transparent)
  - Grid lines: rgba(100, 100, 100, 0.2) (subtle separator)
  - Text overlay: Week count, age, percentage
  - Size: 1200Ã—1800px (mobile-friendly aspect ratio)
  - Save to: `~/Research/vault/temp_images/life-weeks-{date}.png`

**Design Inspiration**: Tim Urban's "Your Life in Weeks" grid from Wait But Why.

### 3. Scheduled Task Implementation
**New File**: `scripts/proactive_tasks/tasks/life_weeks_notification.py`

**Pattern**: Inherit from `BaseTask` (see `scripts/proactive_tasks/base_task.py`).

**Key Methods**:
```python
class LifeWeeksNotificationTask(BaseTask):
    @property
    def name(self) -> str:
        return "life-weeks-notification"

    @property
    def description(self) -> str:
        return "Weekly 'weeks lived' visualization with reflection prompt"

    async def execute(self) -> TaskResult:
        # 1. Query all users with life_weeks_enabled=True
        # 2. For each user:
        #    - Calculate weeks lived
        #    - Generate image
        #    - Send via subprocess isolation (send_photo_sync)
        #    - Track message context with LIFE_WEEKS_REFLECTION type
        # 3. Return TaskResult with success, file paths, stats
```

**Database Query**:
```python
from src.core.database import get_db_session
from src.models.user_settings import UserSettings

async with get_db_session() as session:
    result = await session.execute(
        select(UserSettings).where(UserSettings.life_weeks_enabled == True)
    )
    users = result.scalars().all()
```

**Telegram Integration** (subprocess pattern from CLAUDE.md):
```python
# Use existing helpers - never call Telegram API directly
from src.bot.handlers import send_message_sync

# Send image with caption
send_message_sync(
    bot_token=settings.telegram_bot_token,
    chat_id=user.user_id,
    photo_path=image_path,
    caption=f"Week {weeks_lived} of your life ğŸŒŸ\n\nReflect on this week?",
)
```

**Reply Context Tracking**:
```python
from src.services.reply_context import get_reply_context_service, MessageType

# Track with new message type
reply_service = get_reply_context_service()
reply_service.track_message(
    message_id=sent_message.message_id,
    chat_id=user.user_id,
    user_id=user.user_id,
    message_type=MessageType.LIFE_WEEKS_REFLECTION,  # NEW
    metadata={
        "weeks_lived": weeks_lived,
        "date_of_birth": user.date_of_birth,
        "reply_destination": user.life_weeks_reply_destination,
        "custom_path": user.life_weeks_custom_path,
    }
)
```

### 4. Reply Context Extension
**File**: `src/services/reply_context.py`

**Changes**:
1. Add new `MessageType` enum value:
   ```python
   class MessageType(Enum):
       # ... existing types ...
       LIFE_WEEKS_REFLECTION = "life_weeks_reflection"
   ```

2. Add metadata fields to `ReplyContext` dataclass:
   ```python
   # Life weeks reflection-specific
   weeks_lived: Optional[int] = None
   life_weeks_reply_destination: Optional[str] = None
   life_weeks_custom_path: Optional[str] = None
   ```

3. Update `get_context_summary()` method:
   ```python
   elif self.message_type == MessageType.LIFE_WEEKS_REFLECTION:
       return f"[Life reflection: Week {self.weeks_lived}]"
   ```

4. Update `build_reply_prompt()` method to handle routing logic (see section 5 below).

### 5. Reply Handler for Vault Routing
**New File**: `src/services/life_weeks_reply_handler.py`

**Purpose**: Route reply text to correct vault location based on user settings.

**Key Function**:
```python
async def handle_life_weeks_reply(
    user_id: int,
    reply_text: str,
    context: ReplyContext,
) -> Path:
    """
    Route life weeks reflection to configured vault location.

    Returns:
        Path to the file where reflection was appended.
    """
    destination = context.metadata.get("reply_destination", "daily_note")

    if destination == "daily_note":
        # Append to Daily/YYYYMMDD.md under ## Life Reflection section
        today = datetime.now().strftime("%Y%m%d")
        path = Path(f"~/Research/vault/Daily/{today}.md").expanduser()
        section = "## Life Reflection"

    elif destination == "weekly_note":
        # Append to YYYY-W## note
        iso_year, iso_week, _ = datetime.now().isocalendar()
        path = Path(f"~/Research/vault/Weekly/{iso_year}-W{iso_week:02d}.md").expanduser()
        section = "## Life Reflections"

    elif destination == "custom_journal":
        # Use custom path from settings
        custom_path = context.metadata.get("custom_path")
        if not custom_path:
            custom_path = "~/Research/vault/Journal/life-reflections.md"
        path = Path(custom_path).expanduser()
        section = f"## Week {context.weeks_lived}"

    # Append to file
    _append_to_note(path, section, reply_text)

    return path
```

**Integration Point**: Called from `src/bot/combined_processor.py` when processing replies with `LIFE_WEEKS_REFLECTION` context.

### 6. Combined Processor Integration
**File**: `src/bot/combined_processor.py`

**Changes**: Add handling for `LIFE_WEEKS_REFLECTION` reply type in the message processing flow.

```python
# In process_combined_message() or similar
if reply_context and reply_context.message_type == MessageType.LIFE_WEEKS_REFLECTION:
    from src.services.life_weeks_reply_handler import handle_life_weeks_reply

    # Route reply to vault
    saved_path = await handle_life_weeks_reply(
        user_id=combined.user_id,
        reply_text=combined.text,
        context=reply_context,
    )

    # Send confirmation
    await combined.reply_text(
        f"âœï¸ Reflection saved to {saved_path.name}",
        parse_mode="HTML"
    )

    return  # Message handled
```

### 7. Settings UI Extension
**File**: `src/bot/handlers/voice_settings_commands.py`

**Changes**: Add settings panel for Life Weeks configuration.

**New Command**: `/settings_lifeweeks` (or add to main `/settings` UI)

**Callback Handlers**:
- `lifeweeks:enable` - Toggle life_weeks_enabled
- `lifeweeks:set_dob` - Trigger conversation state to collect DOB
- `lifeweeks:set_time` - Inline keyboard with time options
- `lifeweeks:destination:{type}` - Set reply destination (daily_note/weekly_note/custom_journal)
- `lifeweeks:custom_path` - Trigger conversation state to collect custom path

**UI Layout** (InlineKeyboardMarkup):
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Life Weeks Notification        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Status: Enabled âœ…             â”‚
â”‚  Birthday: 1984-04-25           â”‚
â”‚  Day: Wednesday (auto)          â”‚
â”‚  Time: 09:00                    â”‚
â”‚  Reply Destination: Daily Note  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  [ Edit Birthday ]              â”‚
â”‚  [ Edit Time ]                  â”‚
â”‚  [ Change Destination ]         â”‚
â”‚  [ Disable ]                    â”‚
â”‚  [ â† Back to Settings ]         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 8. Task Registry Configuration
**File**: `scripts/proactive_tasks/task_registry.yaml`

**Add New Entry**:
```yaml
tasks:
  # ... existing tasks ...

  life-weeks-notification:
    enabled: true
    description: "Weekly life weeks visualization with reflection prompt"
    module: "scripts.proactive_tasks.tasks.life_weeks_notification"
    class: "LifeWeeksNotificationTask"
    schedule:
      # Dynamic per-user, but default to Wednesday 9:00 AM
      # Note: Individual users have their own schedule based on DOB
      day_of_week: 2  # Wednesday (0=Monday)
      hour: 9
      minute: 0
    config:
      max_age_years: 90  # Assume 90-year lifespan for grid
      image_width: 1200
      image_height: 1800
      grid_padding: 40
      cell_size: 20
    telegram:
      enabled: true
      # chat_id is per-user, queried from user_settings
    outputs:
      - type: image_file
        path: "~/Research/vault/temp_images/life-weeks-{date}.png"
      - type: telegram_photo
```

### 9. Launchd Plist for Scheduling
**New File**: `~/Library/LaunchAgents/com.telegram-agent.life-weeks.plist`

**Schedule**: Every Wednesday at 9:00 AM (user's personal week start).

**Note**: Since schedule is per-user and we have only one user (161427550), we can use a single plist. For multi-user support, the task would run daily and check each user's schedule internally.

**Plist Structure**:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.telegram-agent.life-weeks</string>
    <key>ProgramArguments</key>
    <array>
        <string>/opt/homebrew/bin/python3.11</string>
        <string>/Users/server/ai_projects/telegram_agent/scripts/proactive_tasks/task_runner.py</string>
        <string>life-weeks-notification</string>
    </array>
    <key>StartCalendarInterval</key>
    <dict>
        <key>Weekday</key>
        <integer>3</integer>  <!-- Wednesday -->
        <key>Hour</key>
        <integer>9</integer>
        <key>Minute</key>
        <integer>0</integer>
    </dict>
    <key>StandardOutPath</key>
    <string>/Users/server/ai_projects/telegram_agent/logs/life_weeks.log</string>
    <key>StandardErrorPath</key>
    <string>/Users/server/ai_projects/telegram_agent/logs/life_weeks.err.log</string>
</dict>
</plist>
```

**Installation**:
```bash
launchctl load ~/Library/LaunchAgents/com.telegram-agent.life-weeks.plist
```

### 10. Plugin Settings Infrastructure (Extensibility)
**Goal**: Allow plugins to register their own settings panels.

**New File**: `src/core/plugin_settings.py`

**Pattern**: Registry-based system where plugins can register settings schemas.

```python
from dataclasses import dataclass
from typing import Callable, Dict, List, Optional

@dataclass
class PluginSettingField:
    """Definition of a single setting field."""
    key: str  # Database column name
    label: str  # Display name
    field_type: str  # text, toggle, select, number, date
    default: Any
    options: Optional[List[tuple]] = None  # For select type: [(value, label), ...]
    validation: Optional[Callable] = None

@dataclass
class PluginSettingsPanel:
    """Settings panel for a plugin."""
    plugin_name: str
    panel_title: str
    description: str
    callback_prefix: str  # e.g., "claude_settings"
    fields: List[PluginSettingField]
    handler: Callable  # Async function to handle callbacks

class PluginSettingsRegistry:
    """Global registry for plugin settings."""
    _panels: Dict[str, PluginSettingsPanel] = {}

    @classmethod
    def register_panel(cls, panel: PluginSettingsPanel):
        cls._panels[panel.plugin_name] = panel

    @classmethod
    def get_panel(cls, plugin_name: str) -> Optional[PluginSettingsPanel]:
        return cls._panels.get(plugin_name)

    @classmethod
    def get_all_panels(cls) -> List[PluginSettingsPanel]:
        return list(cls._panels.values())
```

**Usage in Plugin** (`plugins/claude_code/plugin.py`):
```python
async def on_load(self, container) -> bool:
    from src.core.plugin_settings import PluginSettingsRegistry, PluginSettingsPanel

    panel = PluginSettingsPanel(
        plugin_name="claude-code",
        panel_title="Claude Code Settings",
        description="Configure Claude Code behavior",
        callback_prefix="claude_settings",
        fields=[
            PluginSettingField(
                key="default_model",
                label="Default Model",
                field_type="select",
                default="sonnet",
                options=[("haiku", "Haiku"), ("sonnet", "Sonnet"), ("opus", "Opus")]
            ),
        ],
        handler=self.handle_settings_callback,
    )

    PluginSettingsRegistry.register_panel(panel)
    return True
```

**Integration with Settings UI** (`voice_settings_commands.py`):
```python
@command_handler
async def settings_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show main settings menu with plugin panels."""
    from src.core.plugin_settings import PluginSettingsRegistry

    keyboard = [
        [InlineKeyboardButton("ğŸ™ Voice Settings", callback_data="settings:voice")],
        [InlineKeyboardButton("ğŸ“Š Accountability", callback_data="settings:tracker")],
        [InlineKeyboardButton("ğŸ—“ Life Weeks", callback_data="settings:lifeweeks")],
    ]

    # Add plugin panels
    for panel in PluginSettingsRegistry.get_all_panels():
        keyboard.append([
            InlineKeyboardButton(
                f"ğŸ”Œ {panel.panel_title}",
                callback_data=f"settings:plugin:{panel.plugin_name}"
            )
        ])

    # ... rest of settings UI
```

### 11. Testing Strategy

**Unit Tests** (`tests/services/test_life_weeks_image.py`):
- Test `calculate_weeks_lived()` with known dates
- Test image generation creates valid PNG
- Test grid dimensions and cell counts
- Test edge cases (newborn, centenarian)

**Integration Tests** (`tests/tasks/test_life_weeks_notification.py`):
- Test task execution queries correct users
- Test subprocess isolation for Telegram API
- Test reply context tracking
- Mock Telegram API responses

**Manual Testing**:
1. Set up user with life_weeks_enabled=True
2. Manually run task: `python3.11 scripts/proactive_tasks/task_runner.py life-weeks-notification`
3. Verify image is generated
4. Verify Telegram message is sent
5. Reply to message
6. Verify reply is appended to correct vault note

## Implementation Order

### Phase 1: Core Infrastructure (MVP)
1. âœ… Extend `UserSettings` model with life weeks fields
2. âœ… Implement `life_weeks_image.py` service
3. âœ… Create `life_weeks_notification.py` task
4. âœ… Add `LIFE_WEEKS_REFLECTION` to `MessageType` enum
5. âœ… Implement `life_weeks_reply_handler.py`
6. âœ… Integrate reply handling in `combined_processor.py`

### Phase 2: Settings UI
7. âœ… Add settings panel in `voice_settings_commands.py`
8. âœ… Implement callback handlers for life weeks settings
9. âœ… Add configuration to `task_registry.yaml`

### Phase 3: Scheduling
10. âœ… Create launchd plist
11. âœ… Test manual execution
12. âœ… Load plist and verify automated scheduling

### Phase 4: Plugin Settings (Extensibility)
13. âœ… Implement `plugin_settings.py` registry
14. âœ… Update base plugin to support settings panels
15. âœ… Document plugin settings API
16. âœ… Create example plugin with settings

## Files to Create/Modify

### New Files (9)
1. `src/services/life_weeks_image.py` - Image generation
2. `src/services/life_weeks_reply_handler.py` - Reply routing
3. `scripts/proactive_tasks/tasks/life_weeks_notification.py` - Scheduled task
4. `src/core/plugin_settings.py` - Plugin settings registry
5. `~/Library/LaunchAgents/com.telegram-agent.life-weeks.plist` - Launchd schedule
6. `tests/services/test_life_weeks_image.py` - Unit tests
7. `tests/tasks/test_life_weeks_notification.py` - Integration tests
8. `docs/LIFE_WEEKS.md` - Feature documentation
9. `docs/PLUGIN_SETTINGS.md` - Plugin settings API docs

### Modified Files (7)
1. `src/models/user_settings.py` - Add life weeks fields
2. `src/services/reply_context.py` - Add LIFE_WEEKS_REFLECTION type
3. `src/bot/combined_processor.py` - Add reply handler
4. `src/bot/handlers/voice_settings_commands.py` - Add settings UI
5. `scripts/proactive_tasks/task_registry.yaml` - Add task config
6. `src/core/database.py` - Add migration for new columns
7. `src/plugins/base.py` - Add settings panel support (optional)

## Dependencies

### Python Packages (already installed)
- `Pillow` - Image generation (PIL)
- `sqlalchemy` - Database ORM
- `python-telegram-bot` - Telegram API
- `pyyaml` - Config parsing

### External Services
- None (all local)

## Configuration

### Environment Variables
None required (uses existing Telegram bot token).

### Config Files
- `config/defaults.yaml` - Can add default values for life weeks settings
- `scripts/proactive_tasks/task_registry.yaml` - Task configuration
- `~/Library/LaunchAgents/com.telegram-agent.life-weeks.plist` - Schedule

## Security & Privacy Considerations

1. **Date of Birth Storage**: Stored in local SQLite database (already encrypted at rest via macOS FileVault)
2. **No External APIs**: All processing happens locally
3. **Vault Access**: Uses existing vault path permissions
4. **Telegram Privacy**: Images sent only to user's private chat

## Future Enhancements (Out of Scope)

1. Multi-user support with individual schedules
2. Customizable grid colors/themes
3. Multiple life events markers (graduation, marriage, etc.)
4. Export as PDF for printing
5. Share anonymized grid to social media
6. Voice reflection recording (audio note instead of text)
7. AI-generated reflection prompts based on week number

## Success Criteria

- âœ… User receives weekly image on Wednesday at 9:00 AM
- âœ… Image shows correct weeks lived calculation
- âœ… Reply to image is saved to configured vault location
- âœ… Settings UI allows configuration of all parameters
- âœ… Plugin settings infrastructure is documented and extensible
- âœ… Zero manual intervention required after initial setup

## Rollback Plan

If issues arise:
1. Disable task: `launchctl unload ~/Library/LaunchAgents/com.telegram-agent.life-weeks.plist`
2. Set `life_weeks_enabled=False` in database
3. Remove task entry from `task_registry.yaml`
4. Database columns are nullable, so no data loss

## Timeline Estimate

- **Phase 1 (Core)**: 3-4 hours
- **Phase 2 (Settings)**: 2-3 hours
- **Phase 3 (Scheduling)**: 1 hour
- **Phase 4 (Plugin Settings)**: 2-3 hours
- **Testing & Documentation**: 2 hours
- **Total**: ~10-13 hours

## Notes

- Birthday is Wednesday (1984-04-25), so weekly notification on Wednesday aligns with personal week start
- Grid assumes 90-year lifespan (configurable in task config)
- Image generation uses Pillow (PIL) - no external API calls
- Reply context TTL is 24 hours (configurable in `reply_context.py`)
- Plugin settings registry is opt-in - existing plugins work without changes
